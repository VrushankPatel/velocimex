package strategy

import (
	"context"
	"sync"
	"time"

	"github.com/shopspring/decimal"
	"velocimex/internal/orderbook"
)

// Strategy is the interface that all trading strategies must implement
type Strategy interface {
	GetID() string
	GetName() string
	Start(ctx context.Context) error
	Stop() error
	IsRunning() bool
	GetResults() StrategyResults
	GenerateSignals(orderBooks map[string]*orderbook.OrderBook) ([]*Signal, error)
}

// Signal represents a trading signal for backtesting
type Signal struct {
	Symbol     string                 `json:"symbol"`
	Exchange   string                 `json:"exchange"`
	Side       string                 `json:"side"` // "BUY" or "SELL"
	Quantity   decimal.Decimal       `json:"quantity"`
	Price      decimal.Decimal       `json:"price"`
	Metadata   map[string]interface{} `json:"metadata"`
}

// TradeSignal represents a trading signal generated by a strategy
type TradeSignal struct {
	Strategy   string    `json:"strategy"`
	Symbol     string    `json:"symbol"`
	Side       string    `json:"side"` // "buy" or "sell"
	Price      float64   `json:"price"`
	Volume     float64   `json:"volume"`
	Exchange   string    `json:"exchange"`
	Timestamp  time.Time `json:"timestamp"`
	Confidence float64   `json:"confidence"` // 0-1 scale
	Reason     string    `json:"reason"`
}

// Position represents a current trading position
type Position struct {
	Strategy  string    `json:"strategy"`
	Symbol    string    `json:"symbol"`
	Side      string    `json:"side"` // "long" or "short"
	EntryPrice float64   `json:"entryPrice"`
	Volume    float64   `json:"volume"`
	Exchange  string    `json:"exchange"`
	OpenTime  time.Time `json:"openTime"`
	PnL       float64   `json:"pnl"`
}

// StrategyMetrics represents performance metrics for a strategy
type StrategyMetrics struct {
	WinRate        float64 `json:"winRate"`
	AverageProfit  float64 `json:"averageProfit"`
	AverageLoss    float64 `json:"averageLoss"`
	ProfitFactor   float64 `json:"profitFactor"`
	SharpeRatio    float64 `json:"sharpeRatio"`
	DrawdownMax    float64 `json:"drawdownMax"`
	AverageLatency float64 `json:"averageLatency"`
}

// StrategyResults contains the current results of a strategy
type StrategyResults struct {
	Name             string          `json:"name"`
	Running          bool            `json:"running"`
	StartTime        time.Time       `json:"startTime"`
	LastUpdate       time.Time       `json:"lastUpdate"`
	SignalsGenerated int             `json:"signalsGenerated"`
	ProfitLoss       float64         `json:"profitLoss"`
	RecentSignals    []TradeSignal   `json:"recentSignals"`
	CurrentPositions []Position      `json:"currentPositions"`
	Metrics          StrategyMetrics `json:"metrics"`
}

// Engine manages all trading strategies
type Engine struct {
	orderBooks *orderbook.Manager
	strategies map[string]Strategy
	mu         sync.RWMutex
}

// NewEngine creates a new strategy engine
func NewEngine(bookManager *orderbook.Manager) *Engine {
	return &Engine{
		orderBooks: bookManager,
		strategies: make(map[string]Strategy),
	}
}

// RegisterStrategy registers a new strategy with the engine
func (e *Engine) RegisterStrategy(strategy Strategy) {
	e.mu.Lock()
	defer e.mu.Unlock()
	
	e.strategies[strategy.GetName()] = strategy
	
	// If the strategy is an ArbitrageStrategy, set its order book manager
	if arbStrategy, ok := strategy.(*ArbitrageStrategy); ok {
		arbStrategy.SetOrderBookManager(e.orderBooks)
	}
}

// UnregisterStrategy removes a strategy from the engine
func (e *Engine) UnregisterStrategy(name string) {
	e.mu.Lock()
	defer e.mu.Unlock()
	
	delete(e.strategies, name)
}

// GetStrategy returns a strategy by name
func (e *Engine) GetStrategy(name string) (Strategy, bool) {
	e.mu.RLock()
	defer e.mu.RUnlock()
	
	strategy, exists := e.strategies[name]
	return strategy, exists
}

// GetAllStrategies returns all registered strategies
func (e *Engine) GetAllStrategies() []Strategy {
	e.mu.RLock()
	defer e.mu.RUnlock()
	
	result := make([]Strategy, 0, len(e.strategies))
	for _, strategy := range e.strategies {
		result = append(result, strategy)
	}
	
	return result
}

// GetAllResults returns results for all strategies
func (e *Engine) GetAllResults() map[string]StrategyResults {
	e.mu.RLock()
	defer e.mu.RUnlock()
	
	results := make(map[string]StrategyResults)
	for name, strategy := range e.strategies {
		results[name] = strategy.GetResults()
	}
	
	return results
}

// StartAll starts all registered strategies
func (e *Engine) StartAll(ctx context.Context) error {
	e.mu.RLock()
	defer e.mu.RUnlock()
	
	for _, strategy := range e.strategies {
		if err := strategy.Start(ctx); err != nil {
			return err
		}
	}
	
	return nil
}

// StopAll stops all registered strategies
func (e *Engine) StopAll() error {
	e.mu.RLock()
	defer e.mu.RUnlock()
	
	for _, strategy := range e.strategies {
		if err := strategy.Stop(); err != nil {
			return err
		}
	}
	
	return nil
}